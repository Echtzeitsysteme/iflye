import "http://www.eclipse.org/emf/2002/Ecore"
import "platform:/resource/network.model/model/Model.ecore"

//
// Servers
//

// Substrate server must have at least the required resources available.
rule serverMatchPositive() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateNode: SubstrateServer {
		.residualCpu := substrateNode.residualCpu - virtualNode.cpu
		.residualMemory := substrateNode.residualMemory - virtualNode.memory
		.residualStorage := substrateNode.residualStorage - virtualNode.storage
		++ -guestServers -> virtualNode
	}
	virtualNode: VirtualServer {
		++ -host -> substrateNode
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateNode
	}
	
	virtualNetwork: VirtualNetwork {
		-nodes -> virtualNode
	}
	
	// Check residual resources
	# virtualNode.cpu <= substrateNode.residualCpu
	# virtualNode.memory <= substrateNode.residualMemory
	# virtualNode.storage <= substrateNode.residualStorage
}

// All theoretical possible server mappings but without the positive ones.
// (These are forbidden via the condition below.)
rule serverMatchNegative() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateNode: SubstrateServer {
		.residualCpu := substrateNode.residualCpu + virtualNode.cpu
		.residualMemory := substrateNode.residualMemory + virtualNode.memory
		.residualStorage := substrateNode.residualStorage + virtualNode.storage
		-- -guestServers -> virtualNode
	}
	virtualNode: VirtualServer {
		-- -host -> substrateNode
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateNode
	}
	
	virtualNetwork: VirtualNetwork {
		-nodes -> virtualNode
	}
	
	// Check total resources
	# virtualNode.cpu <= substrateNode.cpu
	# virtualNode.memory <= substrateNode.memory
	# virtualNode.storage <= substrateNode.storage
} when serverMatchNotPossible

condition serverMatchNotPossible = forbid serverMatchPositive

//
// Switches
//

// Match from virtual switch to substrate node.
// (Substrate node could either be a server or a switch.)
rule switchNodeMatchPositive() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateNode: SubstrateNode {
		++ -guestSwitches -> virtualSwitch
	}
	virtualSwitch : VirtualSwitch {
		++ -host -> substrateNode
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateNode
	}
	
	virtualNetwork: VirtualNetwork {
		-nodes -> virtualSwitch
	}
}

//
// Links
//

// Match from a virtual link to a substrate path (positive).
rule linkPathMatchPositive() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substratePath: SubstratePath {
		++ -guestLinks -> virtualLink
		.residualBandwidth := substratePath.residualBandwidth - virtualLink.bandwidth
		// TODO: There is no 'for-each' like functionality. Therefore, we have to update 
		// the bandwidth of all substrate links contained in the substrate path "by hand".
		
	}
	virtualLink: VirtualLink {
		++ -host -> substratePath
	}
	
	substrateNetwork: SubstrateNetwork {
		-paths -> substratePath
	}
	
	virtualNetwork: VirtualNetwork {
		-links -> virtualLink
	}
	
	# virtualLink.bandwidth <= substratePath.residualBandwidth
}

// All theoretical possible link-to-path mappings but without the positive ones.
// (These are forbidden via the condition v.bw > s.residualBw.)
rule linkPathMatchNegative() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substratePath: SubstratePath {
		-- -guestLinks -> virtualLink
		.residualBandwidth := substratePath.residualBandwidth + virtualLink.bandwidth
		// TODO: There is no 'for-each' like functionality. Therefore, we have to update 
		// the bandwidth of all substrate links contained in the substrate path "by hand".
	}
	virtualLink: VirtualLink {
		-- -host -> substratePath
	}
	
	substrateNetwork: SubstrateNetwork {
		-paths -> substratePath
	}
	
	virtualNetwork: VirtualNetwork {
		-links -> virtualLink
	}
	
	# virtualLink.bandwidth > substratePath.residualBandwidth
	# virtualLink.bandwidth <= substratePath.bandwidth
}

// Match from virtual link to substrate server.
// This one does not have any constraints.
rule linkServerMatchPositive() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateServer: SubstrateServer {
		++ -guestLinks -> virtualLink
	}
	virtualLink: VirtualLink {
		++ -host -> substrateServer
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateServer
	}
	
	virtualNetwork: VirtualNetwork {
		-links -> virtualLink
	}
}
